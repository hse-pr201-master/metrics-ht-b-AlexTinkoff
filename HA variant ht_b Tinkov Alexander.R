# Всем привет! Для начала домашки загрузим необходимые пакеты и объясним, для чего они нам нужны.
library(tidyverse) # манипуляции с данными и графики
library(mfx) # предельные эффекты в логит-пробит моделях
library(rio) # если читать внешний набор данных (в нашем случае это csv)
library(lmtest) # для тестов LR, LM, Wald, ...
library(texreg) # представление результатов в табличках в тех (или в ворд)
library(ivpack) # IV и 2SLS
library(dplyr) # на всякий случай для работы с данными
#зафиксируем seed в соответствии с правилами игры
set.seed(0)
# Загрузим наш файл с данными
data = import("C:/Users/Александр/Desktop/HA Metrics/country_profile_variables.csv")
# Посмотрим на наши данные, чтобы отобрать объясняемую переменную, регрессоры и начать наше увлекательное исследование
view(data)
summary(data)

# Сформулируем исследовательский вопрос - Задание №1
# Я хочу изучить, как связан такой важный индикатор масштаба экономики страны, как ВВП с импортной деятельностью страны, выработкой (производством) энергии, рождаемостью, площадью территории, населением и расходами на медицину. Для этого в качестве непрерывной зависимой переменной я возьму логарифм переменной ВВП (в денежном выражении). Похожие исследование о зависимости ВВП от отобранных факторов провели и румынские учёные Constantin Angelache и Cristina Sacala в работе под названием Multiple linear reggression used to analyze the correlation between GDP and some variables (2019)

# Поясним логику выбора объясняющих переменных - Задание №2
# В качестве непрерывной переменной я беру выработку (производство) энергии и импортную деятельность страны. Переменная была выбрана не случайно, а именно благодаря НИСу с Левиным, который упоминал, что чем больше в стране вырабатывается энергии в различных её проявлениях, тем страна является более развитой (действительно - электрификация, активность промышленности, потребление энергетических ресурсов, использование технологий, развитые транспортные системы и дорожные, железнодорожные сети - всё это хорошо характеризует масштаб экономики страны, поэтому ожидаемый эффект позитивный, ведь чем больше энергии вырабатывает страна, тем мощнее экономика). 
# В качестве первой дамми-переменной решил взять рождаемость (в данном случае, если индекс рождаемости > 2 детей, то к этому будет применена "1", что соответствует высокой рождаемости, а если меньше или равно 2 детей, тогда "0", что будет соответствовать низкой рождаемости: ожидаемый эффект согласно мальтузианской теории - отрицательный, так как в развитых странах низкая рождаемость и сильный вклад в небольшое количество детей, а в странах третьего мира стараются завести как можно больше детей "авось успешным станет" или из-за высокой детской смертности). Вторая бинарная переменная будет соответствовать площади территории страны (большая страна будет с циферкой "1" если её площадь превышает или равняется 600 тыс. км2, а если меньше, то страна маленькая и обозначается "0" - ожидаемый эффект отрицательный, так как, в основном, большинство развитых стран мира попадают под критерии небольших стран, а у больших стран свои большие проблемы)
# В качестве нелинейных переменных возьмём логарифм городского населения и логарифм расходов на здравоохранение. Первая логарифмированная переменная поможет нам проанализировать чувствительность ВВП к изменению доли городского населения (ожидаемый эффект - положительный; урбанизация - двигатель экономического развития) а вторая прологарифмированная переменная расходов на здравоохранение также продемонстрирует чувствительность ВВП к здоровью нации (сильнее медицина - здоровее люди - экономика эффективнее, ожидаемое влияние положительное). 

# Посмотрим на колонки с данными, чтобы посмотреть под какими номерами колонок хранятся нужные нам переменные
colnames(data)
# Начнём упрощать названия для более удобной работы
names(data)[7] <- "gdp"
names(data)[3] <- "sizeterr"
names(data)[25] <- "urbpop"
names(data)[27] <- "fertility"
names(data)[46] <- "energyprod"
names(data)[33] <- "exphealth"

# Почистим данные от несуразицы в них
data$gdp[data$gdp == -99] <- NA
data$exphealth[data$exphealth == -99] <- NA
data$sizeterr[data$sizeterr == -99] <- NA
data$energyprod[data$energyprod == -99] <- NA
data$urbpop[data$urbpop == 0] <- NA
data$fertility[data$fertility == -99] <- NA

# Заменим пропущенные значения средними значениями по всей выборки внутри переменной
data$exphealth[is.na(data$exphealth)] = 0
data$exphealth = as.numeric(data$exphealth)
m = mean(data$exphealth)
data$exphealth[data$exphealth == 0] = m
hist(data$exphealth)
mean(data$exphealth)

data$urbpop[is.na(data$urbpop)] = 0
data$urbpop = as.numeric(data$urbpop)
m1 = mean(data$urbpop)
data$urbpop[data$urbpop == 0] = m1
hist(data$urbpop)
mean(data$urbpop) 

data$energyprod[is.na(data$energyprod)] = 0
data$energyprod = as.numeric(data$energyprod)
m2 = mean(data$energyprod)
data$energyprod[data$energyprod == 0] = m2
hist(data$energyprod)
mean(data$energyprod) 

data$sizeterr[is.na(data$sizeterr)] = 0
data$sizeterr = as.numeric(data$sizeterr)
m3 = mean(data$sizeterr)
data$sizeterr[data$sizeterr == 0] = m3
hist(data$sizeterr)
mean(data$sizeterr) 

data$fertility[is.na(data$fertility)] = 0
data$fertility = as.numeric(data$fertility)
m4 = mean(data$fertility)
data$sizeterr[data$sizeterr == 0] = m4
hist(data$fertility)
mean(data$fertility) 

# От пропущенных переменных мы с доблестью избавились, но теперь надо создать переменные, с которыми мы будем работать (объясняемая, регрессоры)
gdpln = log(data$gdp)
data <- data.frame(gdpln, data)
urbanpln = log(data$urbpop)
data <- data.frame(urbanpln, data)
exphlthln = log(data$exphealth)
data <- data.frame(exphlthln, data)
# Теперь займёмся фиктивными переменными (бинарные)
dummy_fert <- NULL
dummy_fert[data$fertility > 2] = 1
dummy_fert[data$fertility < 2] = 0
data <- data.frame(dummy_fert, data)
dummy_sizetr <- NULL
dummy_sizetr[data$sizeterr > 600000] = 1
dummy_sizetr[data$sizeterr < 600000] = 0
data <- data.frame(dummy_sizetr, data)


# Задание №3 - так как внутри переменных пропущенные значения были заполнены заранены, визуализация регрессоров (думаю, что красивые графики получились)
hist(data$energyprod, breaks = 100, col = "blue", xlab = "Values of energy production", ylab = "Frequency of value", main = "Energy Production Distribution") # отличное изображение распределения, видим выбросы справа (после значений на уровне в 250-300)
hist(data$dummy_fert, breaks = 50, col = "blue", xlab = "High (1) or Low (2) Fertility", ylab = "Frequency", main = "Dummy Fertility") # c дамми-переменной всё очевидно (все значения делятся на 0 или 1, а в предыдущем задании выборки были очищены и подготовлены)
hist(data$dummy_sizetr, breaks = 50, col = "blue", xlab = "Large (1) or Tiny (0) Size", ylab = "Frequency", main = "Dummy Territory Size") # c дамми-переменной всё очевидно (все значения делятся на 0 или 1, а в предыдущем задании выборки были очищены и подготовлены)
hist(data$urbpop, breaks = 100, col = "blue", xlab = "Values of urban population", ylab = "Frequency", main = "Urban Population Distribution") # наблюдаем выбросы справа (после значений на уровне 95-99)
hist(data$exphealth, breaks = 100, col = "blue", xlab = "Values of health expenses", ylab = "Frequency", main = "Health Expenses Distribution") # наблюдаем выбросы справа (после значений на уровне 13)
# Поработаем с выбросами и удалим их, так как это самый распространённый способ
data$energyprod[data$energyprod > 275] <- NA
na.omit("energyprod")
data$urbpop[data$urbpop > 97] <- NA
na.omit("urbpop")
data$exphealth[data$exphealth > 13] <- NA
na.omit("exphealth")


# Задание №4 - Наконец-то дошли до спецификации модели
modelfirst = lm(data$gdpln ~ data$energyprod + data$urbpop + data$exphealth + data$dummy_fert + data$dummy_sizetr, data = data)
summary(modelfirst) # большинство коээфициентов получились значимыми, что безусловно хорошо, однако, р квадрат оставляет желать дальшего (но не будем обращать на это внимания, ведь мы занимаемся наукой!)

# Проведём тесты на мультиколлинеарность - воспользуемся индикаторами VIF и CN
# Для начала разберёмся с VIF 
library("car")
vif(modelfirst) # все значения меньше 6, а значит, мультиколлинеарности не наблюдаем
# Теперь разберёмся с CN
install.packages("olsrr")
library(olsrr)
ols_coll_diag(modelfirst) # наибольшее значение, то есть condition number, равно 12, а это меньше 30, поэтому не наблюдаем мультиколлинеарности
# Тесты показали, что мультиколлинеарность в модели не наблюдается

# Теперь проверим на наличие гетероскедастичности - будем использовать самые популярные (Голдфелд-Квант и мистеры Бройш-Паган нам в этом помогут)
library(lmtest)

# Уступим джентельменам: тест Бройша-Пагана в бой
bptest(modelfirst) # Значение p-value превышает любой разумный уровень значимости, поэтому гипотеза H0 не отвергается, у нас нет гетероскедастичности

# Следующий тест будет тест Голдфелда-квандта: для этого необходимо сделать предположения
# Все мы знаем про мем "эй, бумер" - мем пошёл из-за того, что в послевоенное время был бэби-бум, из-за таких всплесков в рождаемости, которые могут случаться, как это было в 1963 году в Австралии (к примеру), можно предположить, что будет гетероскедастичность, так как такие взрывные моменты могут сделать дисперсию очень волатильной
qplot(data = data, fertility, gdpln, main = "Fertility heteroscedasticity analysis") # Достаточно трудно что-то интерпретировать, но выглядит очень не упорядочено, поэтому гетероскедастичность вполне вероятна
# Посмотрим на другие регрессоры- производство энергии связано с технологической революцией, когда были изобретены компьютеры и весь мир стал компьютеризировать всё, больше энергии необходимо
qplot(data = data, energyprod, gdpln, main = "Energy Production heteroscedasticity analysis") # вполне возможно
# Урбанизация - такой социальный феномен, который тоже может оказаться вспышкой
qplot(data = data, urbpop, gdpln, main = "Urban Population heteroscedasticity analysis")# картинки все похожи очень сильно

# Упорядочим данные, как нас учили и выкинем из середины 20% выборки
gqtest <- data[order(data$urbpop), ]
modelsecond <- lm(gdpln ~ urbpop, data = gqtest)
gqtest(modelsecond, fraction = 0.2) # гетероскедастичность наблюдается, так как p-value слишком маленький
gqtest1 <- data[order(data$energyprod), ]
modelthird <- lm(gdpln ~ energyprod, data = gqtest1)
gqtest(modelthird, fraction = 0.2) # гетероскедастичность наблюдается
gqtest2 <- data[order(data$fertility), ]
modelfourth <- lm(gdpln ~ fertility, data = gqtest2)
gqtest(modelfourth, fraction = 0.2) # гетероскедастичности не наблюдается
# Эндогенность - можно воспользоваться тестом Хаусманна для того, чтобы её выявить, но в данном случае неявно, какие переменные могут быть эндогенными, так как все они правдивые 

# Задание №5 
# Против гетероскедастичности будем бороться с помощью робастных ошибок в форме Уайта, где современный вариант использует HC3
# робастные ошибки в форме Уайта HC0 - воспользуемся пакетом, который поможет нам посчитать данные ошибки: устойчивая к гетероскедастичности и автокорреляции формула расчёта ковариационной матрицы оценки коэффициента (сначала представляем бету в классическом виде (X'X)^(-1)X'Y, затем заменяем и подставляем в Y = xB + u, получаем оценку беты в таком виде => Var(бета с крышкой) = (X'X)^(-1)X'Var(u)X(X'X)^(-1)). В современном варианте исчисления робастных ошибок в форме Уайта диагональ матрицы корректируется на (1 - леверидж в форме hij)^2. 
# робастные ошибки, которые устойчивы к гетероскедастичности
vcovHC(modelfirst, type = "HC3")
coeftest(modelfirst, vcov = vcovHC(modelfirst, type = "HC3")) # получили p-value, теперь необходимо их сравнить с нашей первоначальной моделью 
# сравнение с МНК
coeftest(modelfirst)
# все p-value для всех коэффициентов уменьшились, что было достаточно ожидаемо, но при этом количество значимых переменных не изменилось
# Прокомментирую полученные коэффициенты в регрессии и их значимость: хочется отметить, что практически все ожидаемые эффекты оправдались, однако размер территории всё же положительно влияет на развитость экономики страны (наверное, такой результат связан с тем, что такие сильные экономики как Китай, США, Австралия и прочие являются достаточно большими, а ещё у большой страны много ресурсов, поэтому больше возможностей для производства). 
# Интерпретируя значимость коэффициентов: на уровне значимости в 5% коэффициенты при energyprod, urbpop, dummy_fert и dummy_sizetr оказались значимыми, а при exphealth незначимыми
# На ВВП страны положительным образом влияет городское население (так как эта переменная в логарифме и объясняемая тоже - при увеличении на 1% городского населения, ВВП вырастет на 2%)
# На ВВП страны положительным образом влияет производство энергии (если производство увеличится на одну единицу петтаДжоулей, то ВВП увеличится практически на 1%)
# На ВВП страны отрицательным образом влияет высокая рождаемость (действительно, как и предполагали в начале - в основном, у бедных стран, очень высокая рождаемость, а такая интенсивность влияет на выбытие трудовых ресурсов страны)
# На ВВП страны положительным образом влияет расходы на здравоохранение (при их увеличении на 1%, ВВП также вырастет на 1% - здоровее нация, здоровее работники, экономика эффективнее)
# На ВВП страны также положительно влияет и территория (чем больше территория страны, тем больше её потенциал - как в средневековье, однако, нужны хорошие управленцы в главе государства для этого, иначе коррупция и кумовство поглатят государство)







# ЧАСТЬ 2
install.packages("forecast")
install.packages("fable")

# Задание №1

# Выпишем спецификацию модели AR(1), который задаётся следующим уравнением Y(T) = 0.8 * Y(T-1) + e(T)
Y1 = arima.sim(n = 120, list(ar = 0.8))
plot(Y1, ylab = "Y(T)", xlab = "T", main = "AR(1) Process Visualization")
# Для того, чтобы проверить стационарность ряда мы можем составить характеристическое уравнение первого порядка, так как максимальный лаг в 1 период
# Получается, что lambda - 0,8 = 0, следовательно, корень уравнения равен 0,8, что по модулю меньше единицы, поэтому можно утверждать, что процесс является стационарным
# Ряд стационарен в данном случае 

#Выпишем спецификацию модели AR(3), который задаётся следующим уравнением Y(T) = 0.1 * Y(T - 1) + 0.2 * Y(T - 2) + 0.3 * Y(T - 3) + e(T)
Y2 = arima.sim(n = 120, list(ar = c(0.1, 0.2, 0.3)))
plot(Y2, ylab = "Y(T)", xlab = "T", main = "AR(3) Process Visualization")
# Для того, чтобы проверить стационарность ряда мы можем составить характеристическое уравнение третьего порядка, так как максимальный лаг в 3 периода
# Получается, что lambda^3 - 0.1*lambda^2 - 0.2*lambda - 0.3 = 0
# Wolfram подсказывает, что корни этого уравнения являются комплексными -0.353803 - 0.496277 i и -0.353803 + 0.496277 i, чьи модули меньше единицы, поэтому ряд стационарный
# И в этом случае наблюдается стационарность 

#Выпишем спецификацию модели MA(2), который задаётся следующим уравнением Y(T) = e(T) + 1.2e(T - 1) + 2e(T - 2)
Y3 = arima.sim(n = 120, list(ma = c(1.2, 2)))
plot(Y3, ylab = "Y(T)", xlab = "T", main = "MA(2) Process Visualization")
# Как известно, процессы MA всегда стационарны, поэтому этот временной ряд не исключение и является стационарным
# Таким образом, все временные ряды, рассмотренные в 1 задании, являются стационарными

# Задание №2 

# Сгенерируем запрашиваемые временные ряды - начнём с ARIMA(0, 1, 2): в данном случае уравнение будет иметь вид, когда разность единичного порядка просто-напросто будет равняться MA процессу из предыдущего пункта Y(T) - Y(T - 1) = e(T) + 1.2e(T - 1) + 2e(T - 2)
Y4 = arima.sim(n = 120, list(order = c(0, 1, 2), ma = c(1.2, 2)))
# Использовали ma = c(1.2, 2), так как нас просят за основу брать предыдущее задание
plot(Y4, ylab = "Y(T)", xlab = "T", main = "ARIMA(0, 1, 2) Process Visualization")
# Данный ряд не является стационарным, потому что часть MA нестационарна, а части AR по сути не существует из-за заданного условия

# Перейдём к генерации ARIMA (0, 0, 0) - в данном случае такой ряд соответствует просто белому шуму (Y(T) = e(T)), поэтому уже можно сразу предположить, что ряд будет стационарным ввиду того, что дисперсия и матожидания не зависят от времени и стабильны, так как это белый шум
Y5 = arima.sim(n = 120, list(order = c(0, 0, 0)))
plot(Y5, ylab = "Y(T)", xlab = "T", main = "ARIMA(0, 0, 0) Process Visualization")
# Откроем учебник по эконометрике О.А. Демидовой и убедимся в том, что белый шум стационарен, поэтому этот процесс тоже

# Перейдём к генерации ARIMA (3, 0, 0) - в данном случае такой ряд не имеет IMA части, а это значит, что по сути это тот же AR(3): Y(T) = 0.1 * Y(T - 1) + 0.2 * Y(T - 2) + 0.3 * Y(T - 3) + e(T) , который мы уже проверяли на стационарность и выявили её
Y6 = arima.sim(n = 120, list(order = c(3, 0, 0), ar = c(0.1, 0.2, 0.3)))
plot(Y6, ylab = "Y(T)", xlab = "T", main = "ARIMA(3, 0, 0) Process Visualization")
# Процесс стационарен по аналогии с 1 заданием 

#Задание №3

# Вспомнил уравнение случайного блуждания без дрейфа, которое представляется в виде Y(T) = Y(T - 1) + e(T)
# Сгенерируем такой временной ряд и провизуализируем процесс с помощью графика
Y7 = arima.sim(n = 120, list(order = c(0, 1, 0)))
plot(Y7, ylab = "Y(T)", xlab = "T", main = "Random Walk Visualization")
# Ряд не является стационарным, так как в случае "случайного блуждания" математическое ожидание будет нестабильно во времени, поэтому о стационарности процесса не может даже идти речи, на графике +- видно, что он сильно отличается от стационарных процессов, которые я доказал аналитически

# Задание №4 

# Autocorrelation function для AR(1) может представляться в следующем виде Y(T) = 0.8Y(T-1) + e(T) в соответствии с прошлым заданием
acf(Y1, main = "ACF for AR(1)")
pacf(Y1, main = "PACF for AR(1)")
# Теперь сравним автокорреляционную и частную автокорреляционную функцию для случайного блуждания с полученными ранее
acf(Y7, main = "ACF for Random Walk")
pacf(Y7, main = "PACF for Random Walk")
# Давайте попробуем проинтерпретировать полученные результаты для AR(1) и для процесса случайного блуждания
# Как можно заметить из графика ACF for AR(1) автокорреляционная функция имеет меньшие значения при дополнительном лаге, она сначала убывает (что достаточно логично для стационарного процесса), а потом становится незначимой, входя в синюю зону (околонулевую) на больших лагах (7-й лаг) 
# На графике PACF for AR(1) отчётливо видно, как после 1 лага (а у нас первый порядок процесса) процесс обрывается и со второго лага всё попадает в синюю зону - так и должно быть
# Как можно заметить из графика ACF for Random Walk автокорреляционная функция имеет меньшие значения при дополнительном лаге, но она намного стабильнее и убывает менее резко, и затем она становится незначимой на более высоких лагах по сравнению с ACF for R(1) (20-й лаг в этом случае)
# На графике PACF for Random Walk также отчётливо видно, как после 1 лага (а у нас первый порядок процесса) процесс обрывается - так и должно быть


# Задание №5 

# Задание непростое, однако, пользуясь скриптами и материалами Бориса Борисовича с курсеры (как в прошлых номерах), мы преодолеем все невзгоды на пути
# Попробуем сгенерировать запрашиваемый временной ряд
# Например, часть AR(2) (который стационарен) возьмём из 1 задачи варианта экзамена 2017 года: Y(T) = Y(T - 1) - 0.4 * Y(T - 2)
# MA(3) процесс всегда стационарен, поэтому придумаю сам свои коэффициенты: Y(T) = e(T - 1) + 2e(T - 1) + 3e(T - 1) + e(T)
Y8 = arima.sim(n = 120, list(order = c(2, 0, 3), ar = c(1, -0.4), ma = c(1, 2, 3)))
plot(Y8, ylab = "Y(T)", xlab = "T", main = "ARIMA(2, 0, 3) Process Visualization")
summary(Y8)
YLEARN = Y8[1:100] # создали обучающую модель из 100 элементов выборки
YTEST = Y8[101:120] # создали тестовую модель из 20 элементов выборки
# Оценим модель ARIMA(2, 0, 3) по обучающей выборке
modelfirst <- arima(YLEARN, order = c(2, 0, 3))
summary(modelfirst)
AIC(modelfirst)
# Построим прогноз на 20 шагов вперёд 
future <- predict(modelfirst, n.ahead = 20)
future













